#!/usr/local/bin/perl -w

$| = 1;

$PDBDIR = "/data/CASS1/brookhaven/distr";
$PDBPREFIX = "pdb/";
$PDBSUFFIX = ".ent.Z";
$PDB_DISTR = 1;

# Takes "text" output from SCOP and parses it to produce a database
#  ready for STAMP processing.
#
# The idea is to create a directory for reach fold family
#   then to make files in each directory for each family/superfamily.
#
#
# SCOP has 6 levels
#
# Class
# Fold
# Super family
# Protein family
# Protein
# Species
#
#
# Modification following whole database parse
# There are a few problems
#
# 1. the region/chain thing needs to be more general
#  since there are several things like region a:1-56P,b
#  meaning in STAMP format { A 1 _ to A 56 P CHAIN B }
#  fixed 3/7/96
#
# 2. there are also several mistakes in SCOP
#  blatant errors (i.e. wrong region) cannot be helped, but
#  situations where the chains disagree with our version
#  of the PDB might be checked with PDBC or a bit of C code
#
# 3. Problem with multiple domains from a single PDB code/chain
#  short of doing a massive array of counters for each protein code/chain
#  I can't see my way around it.
#  Actually, all one needs is a counter for each fold group
#   this isn't such a big deal.  I'll work on it.
#  A better solution is to assign each domain a number according to 
#   level of the hierarchy: e.g. AB.1.2.3.1.1, this is also
#   a little more meaningful
#
# 4. Another stupid fix, sometimes SCOP says "2. region b" when it actually
#    means "chain b" fixed 26/8/99
#
# 5. Also a problem with negative PDB numbers, fixed 26/8/99
#
# 6. Now comments out identifiers begining with "s" or "0" 27/8/99
#
# Appears now to be more or less robust



# First parse the command line 

if($#ARGV<1) {
  exit_error();
}
$start_fold_number=0;
$domain_only = 0;
for($i=0; $i<=$#ARGV; ++$i) {
   if(substr($ARGV[$i],0,1) !~ /-/ ) { exit_error(); }
   if(substr($ARGV[$i],1,1) =~ /f/) { # Input file
        $scopfile = $ARGV[$i+1];
        $i++;
    } elsif(substr($ARGV[$i],1) =~ /domain_only/) {
	$domain_only=1;
    } elsif(substr($ARGV[$i],1) =~ /start_fold_number/) {
	$start_fold_number=$ARGV[$i+1];
	$i++;
    } else { 
	
	exit_error();
    }
}

open (IN,$scopfile) || die "Error opening file $scopfile\n";

if(-e "scop-big.list") { open(BIG,">>scop-big.list"); }
else { open(BIG,">scop-big.list"); } 

if($domain_only ==1) {
   close(BIG);
   open(BIG,">/dev/null");
}

if(-e "scop.dom") { open(DOM,">>scop.dom"); }
else { open(DOM,">scop.dom"); } 

# Class, Fold, Superfamily, Family, Protein, Species, PDB-entry
#  0      1       2          3         4        5       6
@counters = (0,$start_fold_number,0,0,0,0,0,0);
@totals   = (0,0,0,0,0,0,0,0);
@filebits = ("","","","","","","","");
@names    = ("","","","","","","","");
@layers   = ("CLASS","FOLD","SUPERFAMILY","FAMILY","PROTEIN","SPECIES","PDB_ENTRY","DOMAIN");
@GF = ("","","","","","","","");
@DF = ("","","","","","","","");

#               0      1         2           3        4         5           6         7

# Each level of the hierarchy will contain a 
# domain file and a groups file
#  This will be in the form 
#   all  and    all.groups  folds divided into superfamilies
#   001  and    001.groups  superfamilies divided into families
#   001.001 and 001.001.groups  families into proteins
#   001.001.001 and 001.001.001.groups  proteins into species
#                            

$cur_id = "";

# We want to process the below
#  1. All alpha (71)
#01234567890123456789012345678901234567890
#       1. Globin-like (1) ***
#          core: 6 helices; folded leaf, partly opened;
#            1. Globin-like (2)
#                 1. Globins (32)
#                    Heme-binding protein
#                      1. Hemoglobin I
#                           1. ark clam (Scapharca inaequivalvis) (4)
#01234567890123456789012345678901234567890
#                                1. 3sdh [seq] **
#
#                                   complex with porphyrin
#                                     1. chain a
#
#                                     2. chain b
#
#012345678901234567890123456789012345678901234567890

$not_output_yet=0;
$skip=0;
while(<IN>) {
    chop;
    if((length($_)>4) && (!/^ {35}/) && ($not_output_yet==1)) { 
	 $not_output_yet=0;
	 output_dat(); 
    } 
    if(/^[0-9 ][0-9 ][0-9]\./) { # New class
      print "Class $_\n";
      assign_class();
      if($domain_only==0) { $command = "mkdir "."$class"; system("$command"); }
      new_node(0); 
    } elsif(/^ {5}[0-9 ][0-9 ][0-9]\./) { # New fold
      new_node(1);
      $workingdir = $class . "/" . $counters[1] . "." . substr($names[1],0,15);
      print "Class is $class Working directory is $workingdir\n";
      if(-e $workingdir) {
		$skip = 1;
      } else {
		$skip = 0;
      		if($domain_only==0) { 
		   $command = "mkdir "."$workingdir"; 
		   system("$command");
		} 
      }
   } elsif(($skip==0) && (/^ {10}[0-9 ][0-9 ][0-9]\./)) { # New superfamily
      new_node(2)
   } elsif(($skip==0) && (/^ {15}[0-9 ][0-9 ][0-9]\./)) { # New family
      new_node(3);
   } elsif(($skip==0) && (/^ {20}[0-9 ][0-9 ][0-9]\./)) { # New protein
      new_node(4);
   } elsif(($skip==0) && (/^ {25}[0-9 ][0-9 ][0-9]\./)) { # New species
      new_node(5);
   } elsif(($skip==0) && (/^ {30}[0-9 ][0-9 ][0-9]\./)) { # New ID
      new_node(6);
      $id_suffix = "";
      $ndom=0;
      $cur_id = substr($_,35,4);
      $cur_descriptor = "ALL";
      $not_output_yet=1;
   } elsif(($skip==0) && (/^ {35}[0-9 ][0-9 ][0-9]\./)) { # New chain or region, etc
      $id_suffix = "";
      $ndom++;
      if(substr($_,38,8) =~ /\. region/) {
	 @regions = split(/,/,substr($_,47));
         $nregion = @regions;
         $cur_descriptor = "";
	 printf("%4d regions\n",$nregion);
         for($i=0; $i<$nregion; $i+=1) {
		printf(" Region %4d |%s|\n",$i,$regions[$i]);
              if(length($regions[$i])<=2 ) {  # A single whole chain
                  $cur_descriptor = $cur_descriptor . " CHAIN " . uc(substr($regions[$i],0,1)) . " ";
		  $id_suffix = $id_suffix . lc(substr($regions[$i],0,1));
              } else {
                 if($regions[$i] !~ /:/) { 
		    $chain = '_'; 
                 } else { 
		    $chain = uc(substr($regions[$i],0,1)); 
		    $id_suffix = $id_suffix . lc($chain);
		 }
                 $regions[$i] =~ s/.://;
		 # Now we have some kind of [number]-[number] construction
		 # Here is a fix to keep negative numbers from screwing things up
		 # 	
		 $regions[$i] =~ s/^-/ NEGATIVE /;
		 $regions[$i] =~ s/--/- NEGATIVE /;
		 ($start,$end) = split(/-/,$regions[$i]);
##		 print "Split to |$start| and |$end|\n";
		 if($start =~ /[A-Z]$/) { # insertion code
		    $ins = substr($start,length($start)-1,1);
		    chop($start);
		    $start = $chain . " " . $start . " " . $ins;
		 } else {
		    $start = $chain . " " . $start . " _";
		 }
		 if($end =~ /[A-Z]$/) { # insertion code
		    $ins = substr($end,length($end)-1,1);
		    chop($end);
		    $end = $chain . " " . $end . " " . $ins;
		 } else {
		    $end = $chain . " " . $end . " _";
	         }
#		 print "Now we have to |$start| and |$end|\n";
		 $regions[$i] = " " . $start . " to " . $end . " ";
		 $regions[$i] =~ s/ NEGATIVE /-/g;
		 $cur_descriptor = $cur_descriptor . $regions[$i];
              }
           }

      } elsif(substr($_,38,8) =~ /\. chain/) {
	 $chainbuff=substr($_,46);
	 @chain_ids=split(/,/,$chainbuff);
	 $cur_descriptor = "";
	
	 for($i=0; $i<=$#chain_ids; ++$i) {
  	   $cur_descriptor = $cur_descriptor . " CHAIN " . uc($chain_ids[$i]). " ";
	   $id_suffix = $id_suffix . lc($chain_ids[$i]);
	 }
      }
      output_dat();
      $not_output_yet=0;
   } elsif(($skip==0) && (/^ {35}/)) { # If not an ID then this is a comment
	$comment = $comment . " " . substr($_,35); 
	if(($comment =~ /Mutant/) || ($comment =~ /Non-native/)) { $mutant=1; } 
	else { $mutant=0; }
	if($comment =~ /[Cc]omplex [Ww]ith/) { $complex=1; }
        else { $complex=0; }
   }

}
if($not_output_yet==1) { output_dat(); }


sub output_dat() {
   # Here we have to update
   #  a series of files
   #  fold fold_rep fold.groups 
   #  001.002.... versions of the above for
   #  each node.
   #  "Rep" files will comprise one member of the level below
   #  (i.e. fold_rep will contain one domain entry for each superfamily, etc.)
   # And output a complete list

   $counters[7]++;

   if($x >= 5) {
       $scop_suffix = $filebits[0];
       for($i=1; $i<=7; ++$i) {
          $scop_suffix = $scop_suffix . "." . $counters[$i];
       }
   }

   # Ignore those ids without PDB coordinates
   # This is either the "0abc" entries or the "s0123" entries of Murzin
   if($cur_id =~ /^[s0]/) { $ignore=1; }
   else { $ignore=0; }

   if(($counters[7]==1) && ($ignore==0)) { 
	printf("------ %s%s.%s\n",$cur_id,$id_suffix,$scop_suffix);
    }


   if($PDB_DISTR==1) {
        $two_letter_code = substr($cur_id,1,2);
	$pdbfile =  $PDBDIR . "/" . $two_letter_code . "/". $PDBPREFIX . $cur_id . $PDBSUFFIX;
   } else { 
	$pdbfile =  $PDBDIR . "/" . $PDBPREFIX . $cur_id . $PDBSUFFIX;
   }
   $domain_string = "";
   if($cur_id =~ /^[s0]/) { $domain_string .= "%"; }
   $domain_string .= $pdbfile . " "  . $cur_id . $id_suffix . "." .  $scop_suffix .   " { " . 
	$cur_descriptor . " } ";
   $identifier_string = $cur_id . $id_suffix . "." .  $scop_suffix;

   $filename = $workingdir . "/fold";
   $filename_rep = $workingdir . "/fold_rep";
   $groupsfile = $workingdir . "/fold.groups";

   $DF[1] = $filename;
   $GF[1] = $groupsfile;

   if($ignore==0) { write_to_files (1); } 

   printf("%s\n",$domain_string);
   $namestring = $filebits[2];
   $namerepstring = $filebits[2];
   $lastnamestring = "fold";
   for($i=2; $i<6; ++$i) { # Update all sub-classification files
	if($i>2) {
	   $namestring = $namestring . "." . $filebits[$i];
   	   $namerepstring = $namerepstring . "." . $filebits[$i];
	}

        $filename     = $workingdir . "/" . $namestring;
	$filename_rep = $workingdir . "/" . $namerepstring . "_rep";
	$groupsfile   = $workingdir . "/" . $namestring . ".groups";
        $DF[$i] = $filename;
        $GF[$i] = $groupsfile;
	if($ignore==0) { write_to_files($i); } 
	$lastnamestring = $namestring;

   }
   for($j=0; $j<6; ++$j) {
      printf(BIG "%20s %20s %s\n",$identifier_string,$layers[$j],$names[$j]);
   }
   printf(BIG "%20s Comments_and_other    %s\n",$identifier_string,$comment);
   print DOM $domain_string,"\n";

   new_node(7);
}

sub write_to_files() {

# Outputs data for a particular node in the hierarchy

   $node = $_[0];

   # Domain output
   if($domain_only==0) {
      if(!-e $filename) { system("touch $filename"); }
      open(OUT,">>$filename");
   }  else {
      open(OUT,">/dev/null");
   }
   for($j=0; $j<6; ++$j) {
     printf(OUT "%% %s %s\n",$layers[$j],$names[$j]);
   }
   printf(OUT "%s\n",$domain_string);
   close(OUT);

#   print "Adding ident $identifier_string to file $groupsfile \n";
   # Groups output
   if($domain_only==0) {
     if(!-e $groupsfile) { system("touch $groupsfile"); }
     open(OUT,">>$groupsfile"); printf(OUT "%s ",$identifier_string); close(OUT);
   }  else {
      open(OUT,">/dev/null");
   }


   # Work out whether we are at the first occurence at the node
   $do_rep=1;
   for($j=($node+1); $j<=7; ++$j) {
 	if($counters[$j]>1) { $do_rep=0; }
   }

   if($do_rep==1) {
#     print "OUTPUTING Representative counters: \n";
#     for($j=($node+1); $j<=7; ++$j) { print "$counters[$j] "; }
#     printf("\n");
      if($domain_only==0) {
        if(!-e $filename_rep) { system("touch $filename_rep"); }
        open(OUT,">>$filename_rep");
      }  else {
        open(OUT,">/dev/null");
      }
     for($j=0; $j<6; ++$j) {
       printf(OUT "%% %s %s\n",$layers[$j],$names[$j]);
     }
     printf(OUT "%s\n",$domain_string);

     close(OUT);
   } 
   

}
sub assign_class() {
     	if(/All alpha/) { 
		$class = "A"; 
	} elsif (/All beta/) { 
		$class = "B"; 
	} elsif (/Alpha and beta/) {
                $class = "AB"; 
      	} elsif (/Alpha plus beta/) {
                $class = "ApB";
      	} elsif (/Multi-domain/) { 
		$class = "Mult"; 
	} elsif (/Membrane/) { 
		$class = "Memb"; 
	} elsif (/Small/) { 
		$class = "Small"; 
	} elsif (/Peptides/) { 
		$class = "Pep"; 
	} elsif (/Designed/) { 
		$class = "Des"; 
	} elsif (/Non-protein/) { 
		$class = "Non"; 
	} else {
        	print "Error class not found from $_\n";
	        exit(-1);
      }
}

sub new_node() {

# let x = $_[0]
# At each new node we need to
#   1. close all files for nodes >= x  ... this doesn't need to be done 
#     since we will always be opening and closing ... what does
#     need doing is to update the filenames.
#   2. add return to file for node x-1
#   3. set counters[>x] = 0;
    

    $x=$_[0];

    if($x<7) {
      $names[$x] = substr($_,(($x*5)+5));
      $names[$x] =~ s/\([0-9]*\)//g;
      $names[$x] =~ s/ *$//;
      $names[$x] =~ s/[ \/\*]/_/g;
      $names[$x] =~ s/[()]/_/g;
      $names[$x] =~ s/\&/+/g;
      $names[$x] =~ s/\"//g;
      $names[$x] =~ s/'//g;
    } else {
      $names[$x] = "";
    }

    if($x<7) { $counters[$x]++; } 
    $totals[$x]++;
    for($i=($x+1); $i<=7; ++$i) {
         $counters[$i]=0;
	 if($i==1) { $counters[1] = $start_fold_number; }
    }

    if($x==0) {
	# Class gets a letter/string
	$filebits[0] = $class;
    } else {
        if($counters[$x]<10) { $filebits[$x] = "00" . $counters[$x]; }
        elsif($counters[$x]<100) { $filebits[$x] = "0" . $counters[$x]; }
	else { $filebits[$x] = $counters[$x]; }
    }
#    printf("Filebits are : ");
#    for($i=2; $i<=7; ++$i) { printf("%s.",$filebits[$i]); }
#    printf("\n");
        	

    if(($x>1) && ($x<7)) {
      $lastgroupsfile = $GF[$x-1];
      if($GF[$x-1] ne "") {
#         print "Node level is $x Adding return to file $GF[$x-1]\n";
	 if($domain_only==0) {
           if(!-e $lastgroupsfile) { system("touch $lastgroupsfile"); }
           open(OUT,">>$lastgroupsfile"); printf(OUT "\n"); close(OUT);
	 } 
      }
    }

    for($i=0; $i<$x; ++$i) { printf("-"); }
    printf("%s %s\n",$layers[$i],$names[$i]);
    

    if($x >= 5) {
	  $scop_suffix = $filebits[0];
          for($i=1; $i<=7; ++$i) {
    	     $scop_suffix = $scop_suffix . "." . $counters[$i];
	  }
    }
    if($x<7) { $comment = ""; $complex=0; $mutant=0; }
}

sub exit_error {
   die "format: scop2stamp -f <file> -start_fold_number <int>\n";
}

