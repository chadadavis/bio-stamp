#!/usr/bin/perl -w

#
# Selection filter for alignments
#
# Given a list of strings, will extract only those
#  sequences with identifiers that match one or more 
#  strings, and output the alignment again.
#

use lib '/russell/speedy/russell/progs/stamp.4.3/perl/';
use Palign;


$format{"c"} = "Clustal";
$format{"m"} = "MSF";
$format{"b"} = "AMPS BLOCK";
$format{"f"} = "FASTA";
$format{"p"} = "PIR";
$format{"s"} = "Pfam";

$from = "x"; 
$to   = "x";
$extract = "";
$invert = 0;
$exact = 0;

for($i=0; $i<=$#ARGV; ++$i) {
   if($ARGV[$i] eq "-in") { # conversion specified
 	if(($i+1)>($#ARGV)) { exit_error(); }
	$from = substr($ARGV[$i+1],0,1);
	if($from !~ /[cmbfps]/) { exit_error(); }
	$i++;
   } elsif($ARGV[$i] eq "-out") { # conversion specified
 	if(($i+1)>($#ARGV)) { exit_error(); }
	$to   = substr($ARGV[$i+1],0,1);
	if($to !~ /[cmbfps]/) { exit_error(); } 
	$i++;
   } elsif($ARGV[$i] eq "-list") { # Read in list of ids from a file (one per line)
	if(($i+1)>($#ARGV)) { exit_error(); }
	$listfile = $ARGV[$i+1];
	$i++;
   } elsif($ARGV[$i] eq "-exact") { # exact matches only (not string matching)
	$exact = 1;
   } elsif($ARGV[$i] eq "-v") { # exclude rather than include (like grep -v)
	$invert = 1;
   } elsif(($ARGV[$i] eq "-") || ($ARGV[$i] eq "-help")) {
	exit_error();
   } elsif(!defined($listfile)) {
	$extract .= $ARGV[$i] . " ";
   } else {
	exit_error($ARGV[$i]);
   }
}
if(defined($listfile)) {
	open(IN,"$listfile") || die "Error reading $listfile\n";
	while(<IN>) {
	  chop;
  	  $extract .= $_ . " ";
	}
	close(IN);
}

#printf("Converting from %s to %s (stdin/stdout)\n",$format{$from},$format{$to});
# Read data

@data = read_align("-",$type);
if($from eq "x") {
    $from = $type;
}
if($from eq "x") {
   die "Couldn't figure out alignment type: please specify with \"-in <type>\"\n";
}
if($to eq "x") {
   $to = $from; 
}

if($from eq "m") { 
	$align = get_msf(@data); 
} elsif($from eq "c") {
	 $align = get_clustal(@data); 
} elsif($from eq "b") {
	 $align = get_block(@data); 
} elsif($from eq "f") {
	 $align = get_afasta(@data); 
} elsif($from eq "p") {
	 $align = get_apir(@data); 
} elsif($from eq "s") {
	 $align = get_pfam(@data); 
}


$align2 = extract_align($align,$extract,$invert,$exact);

# Write data 
if($to eq "m") { 
	write_msf($align2,"-"); 
} elsif($to eq "c") {
	write_clustal($align2,"-");
} elsif($to eq "b") {
	write_block($align2,"-");
} elsif($to eq "f") {
	write_afasta($align2,"-");
} elsif($to eq "p") {
	write_apir($align2,"-");
}


sub exit_error {

if(defined($_[0])) {
	print STDERR "Error: couldn't understand command $_[0]\n\n";
}
print STDERR "format: aselect [-in <type> -out <type> -list <file containing ids/strings to keep>] <string1> <string2> ... <stringN> < (file) \n";
print STDERR "   where <type> is one of:\n";
print STDERR "          m = MSF format\n";
print STDERR "          c = Clustal format\n";
print STDERR "          b = AMPS BLOCK format\n";
print STDERR "          f = FASTA format\n";
print STDERR "          p = PIR format\n";
print STDERR "	  s = PFAM (Sanger) format\n";
print STDERR "        defaults are in: any out: the same \n";
print STDERR "	\n";
print STDERR "	-v => like grep -v exclude the ids given\n";
print STDERR "\n";
print STDERR "        either you give a list of ids/strings in a file (one per line)\n";
print STDERR "        or specify ids on the command line separated by spaces\n";

die;
}
